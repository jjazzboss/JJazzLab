/*
 * 
 *   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *  
 *   Copyright @2019 Jerome Lelasseux. All rights reserved.
 * 
 *   This file is part of the JJazzLab software.
 *    
 *   JJazzLab is free software: you can redistribute it and/or modify
 *   it under the terms of the Lesser GNU General Public License (LGPLv3) 
 *   as published by the Free Software Foundation, either version 3 of the License, 
 *   or (at your option) any later version.
 * 
 *   JJazzLab is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Lesser General Public License for more details.
 *  
 *   You should have received a copy of the GNU Lesser General Public License
 *   along with JJazzLab.  If not, see <https://www.gnu.org/licenses/>
 *  
 *   Contributor(s): 
 * 
 */
package org.jjazz.rhythmmusicgeneration.api;

import com.google.common.base.Preconditions;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import org.jjazz.chordleadsheet.api.UnsupportedEditException;
import org.jjazz.midimix.api.MidiMix;
import org.jjazz.phrase.api.Phrase;
import org.jjazz.rhythm.api.MusicGenerationException;
import org.jjazz.rhythm.api.Rhythm;
import org.jjazz.rhythm.api.RhythmVoice;
import org.jjazz.rhythm.api.rhythmparameters.RP_SYS_Variation;
import org.jjazz.rhythmmusicgeneration.spi.MusicGenerator;
import org.jjazz.songcontext.api.SongContext;
import org.jjazz.songstructure.api.SongPart;
import org.jjazz.songstructure.api.SongStructure;
import org.jjazz.utilities.api.IntRange;
import org.jjazz.utilities.api.ResUtil;
import org.jjazz.utilities.api.Utilities;

/**
 * A MusicGenerator which delegates to other destination MusicGenerators.
 * <p>
 * Delegation mechanism is configured via the RvToMgDelegateMapper class.
 * <p>
 * This lets a base Rhythm instance use more than one MusicGenerator, for example :<br>
 * - use an internal MusicGenerator for the bass RhythmVoice and another internal one for the rest of the RhythmVoices<br>
 * - use 2 internal MusicGenerators for the bass RhythmVoice, depending on the SongPart's RP_SYS_Variation value<br>
 * - use the percussion MusicGenerator from another Rhythm instance for our drums<br>
 * - use the Main-C bass track from another Rhythm with note velocities lowered so it better fits the other tracks of the base rhythm
 * <p>
 */
public class CompositeMusicGenerator implements MusicGenerator
{

    protected final static Level LogLevel = Level.FINE;

    /**
     * A MusicGenerator delegate.
     *
     * @param mg               The MusicGenerator delegate
     * @param rv               The destination RhythmVoice to be used by mg
     * @param rpVariationValue An optional destination rhythm's variation to be used by mg. If null, reuse the source variation value.
     * @param postProcessor    An optional post-processor of the phrase generated by mg. If null no postprocessing is done. For example this can be used to
     *                         harmonize notes velocities.
     */
    public record MgDelegate(MusicGenerator mg, RhythmVoice rv, String rpVariationValue, Consumer<Phrase> postProcessor)
            {

        public MgDelegate   
        {
            Objects.requireNonNull(mg);
            Objects.requireNonNull(rv);
        }

        @Override
        public String toString()
        {
            return "MgDelegate(" + mg.getClass().getSimpleName() + "," + rv + "," + rpVariationValue
                    + "," + (postProcessor == null ? "null" : postProcessor.getClass().getSimpleName()) + ")";
        }
    }

    /**
     * Map a base RhythmVoice to a MgDelegate for a given SongPart context.
     * <p>
     * NOTE: MgDelegates using the same MusicGenerator must also use the same rpVariation value. For example if you want to reuse the bass and drums tracks of
     * bossa.sty, then the 2 MgDelegates must have the same rpVariation value (can be null).
     */
    public interface RvToMgDelegateMapper
    {

        /**
         * Get the MgDelegate to be used to generate music for baseRv in the context of spt.
         *
         * @param baseRv A RhythmVoice of the baseRhythm. Can not be null.
         * @param spt    A SongPart which uses the baseRhythm. Can not be null.
         * @return A non-null value
         */
        MgDelegate get(RhythmVoice baseRv, SongPart spt);
    }
    private final RvToMgDelegateMapper baseRvMapper;
    private final Rhythm baseRhythm;
    private static final Logger LOGGER = Logger.getLogger(CompositeMusicGenerator.class.getSimpleName());


    /**
     * Create a CompositeMusicGenerator for a base Rhythm.
     *
     * @param baseRhythm
     * @param baseRvMapper
     */
    public CompositeMusicGenerator(Rhythm baseRhythm, RvToMgDelegateMapper baseRvMapper)
    {
        Objects.requireNonNull(baseRhythm);
        Objects.requireNonNull(baseRvMapper);
        this.baseRhythm = baseRhythm;
        this.baseRvMapper = baseRvMapper;
    }

    public Rhythm getBaseRhythm()
    {
        return baseRhythm;
    }


    @Override
    public Map<RhythmVoice, Phrase> generateMusic(SongContext sgContext, RhythmVoice... rvs) throws MusicGenerationException
    {
        var rvsList = List.of(rvs);
        var rhythmRvs = baseRhythm.getRhythmVoices();
        Preconditions.checkArgument(rvsList.stream().allMatch(rv -> rhythmRvs.contains(rv)), "rvs=", rvsList);
        var rhythmVoices = rvsList.isEmpty() ? rhythmRvs : rvsList;


        Map<RhythmVoice, Phrase> res = new HashMap<>();

        // The SongParts using our rhythm
        var spts = sgContext.getSongParts().stream()
                .filter(spt -> spt.getRhythm() == baseRhythm)
                .toList();


        // Identify the unique MusicGenerators used
        Set<MusicGenerator> uniqueMgs = new HashSet<>();
        for (var spt : spts)
        {
            rhythmVoices.stream()
                    .map(rv -> baseRvMapper.get(rv, spt))
                    .forEach(mgt -> uniqueMgs.add(mgt.mg));
        }


        for (var mg : uniqueMgs)
        {
            List<MgDelegate> prevSptMgDelegates = null;
            List<SongPart> prevSptList = new ArrayList<>();

            for (var spt : spts)
            {
                // Get a MgDelegates vector, with null values for MgDelegates not using mg
                var sptMgDelegates = rhythmVoices.stream()
                        .map(rv -> baseRvMapper.get(rv, spt))
                        .map(mgt -> mgt.mg == mg ? mgt : null)
                        .toList();

                if (prevSptMgDelegates == null)
                {
                    prevSptMgDelegates = sptMgDelegates;
                } else if (!sptMgDelegates.equals(prevSptMgDelegates))
                {
                    // At least one MgDelegate has changed because of the SongPart context, start a music generation on the previous subContext
                    var subContext = getSubContext(sgContext, prevSptList);  // note that SongParts might not be contiguous

                    // Prepare the mg-specific map
                    Map<RhythmVoice, MgDelegate> mapBaseRvMgDelegate = new HashMap<>();
                    for (int i = 0; i < rhythmVoices.size(); i++)
                    {
                        var mgt = prevSptMgDelegates.get(i);
                        if (mgt != null)
                        {
                            mapBaseRvMgDelegate.put(rhythmVoices.get(i), mgt);
                        }
                    }

                    // Get mg to generate music
                    var mapBaseRvPhrases = callGenerator(mg, mapBaseRvMgDelegate, subContext);     // throws MusicGenerationException
                    postProcessPhrases(mapBaseRvPhrases, mapBaseRvMgDelegate);
                    mergePhrases(sgContext.getMidiMix(), res, mapBaseRvPhrases);

                    prevSptList.clear();
                    prevSptMgDelegates = sptMgDelegates;
                }

                prevSptList.add(spt);
            }


            // Music generation for the last subContext
            var subContext = getSubContext(sgContext, prevSptList);
            Map<RhythmVoice, MgDelegate> mapBaseRvMgDelegate = new HashMap<>();
            for (int i = 0; i < rhythmVoices.size(); i++)
            {
                var mgt = prevSptMgDelegates.get(i);
                if (mgt != null)
                {
                    mapBaseRvMgDelegate.put(rhythmVoices.get(i), mgt);
                }
            }
            var mapBaseRvPhrases = callGenerator(mg, mapBaseRvMgDelegate, subContext);     // throws MusicGenerationException
            postProcessPhrases(mapBaseRvPhrases, mapBaseRvMgDelegate);
            mergePhrases(sgContext.getMidiMix(), res, mapBaseRvPhrases);
        }


        return res;
    }

    // =================================================================================================================================
    // Private methods
    // =================================================================================================================================

    /**
     * Generate phrases for a single MusicGenerator which a consistent MgDelegate configuration for all SongParts.
     * <p>
     *
     * @param mg
     * @param mapBaseRvMgDelegate Associates a MgDelegate for some base RhythmVoices (possibly all). All MgDelegates must use mg and have the same
     *                            rpVariationValue
     * @param subContext
     * @return The Phrase generated for each base rhythm voice defined as mapBaseRvMgDelegate's key
     * @throws org.jjazz.rhythm.api.MusicGenerationException
     */
    private Map<RhythmVoice, Phrase> callGenerator(MusicGenerator mg, Map<RhythmVoice, MgDelegate> mapBaseRvMgDelegate, SongContext subContext) throws MusicGenerationException
    {
        Map<RhythmVoice, Phrase> res = new HashMap<>();

        if (mapBaseRvMgDelegate.isEmpty())
        {
            return res;
        }
        var mgDelegates = mapBaseRvMgDelegate.values();
        var mgdSample = mgDelegates.iterator().next();
        var rpVariationValue = mgdSample.rpVariationValue();
        Rhythm delegateRhythm = mgdSample.rv().getContainer();
        var uniqueDelegateRvs = mgDelegates.stream()
                .peek(mgd -> 
                {
                    if (mgd.mg != mg || !Objects.equals(mgd.rpVariationValue, rpVariationValue))
                    {
                        throw new IllegalArgumentException("mg=" + mg + " mgd=" + mgd + " randomMgd=" + mgdSample);
                    }
                })
                .map(mgd -> mgd.rv)
                .collect(Collectors.toSet());   // We might have 2 times the same Rv if redirecting one base RhythmVoice to another base RhythmVoice


        SongContext delegateContext = subContext;      // by default     
        if (delegateRhythm != baseRhythm || rpVariationValue != null)
        {
            // We need a new delegateContext to use delegateRhythm instead of baseRhythm, and/or to use rpVariationValue
            delegateContext = createDelegateContext(subContext, delegateRhythm, rpVariationValue);
        }


        // Call MusicGenerator
        if (LogLevel.intValue() >= Level.INFO.intValue())
        {
            LOGGER.log(LogLevel, "callGenerator() generating music mg={0} subContext={1}  mapBaseRvMgDelegate=", new Object[]
            {
                mg.getClass().getSimpleName(),
                subContext.getSongParts().stream().map(spt -> spt.toShortString()).toList(),
            });
            LOGGER.log(LogLevel, "{0}", Utilities.toMultilineString(mapBaseRvMgDelegate, "      "));
        }
        var mapRvPhrases = mg.generateMusic(delegateContext, uniqueDelegateRvs.toArray(RhythmVoice[]::new));


        // We need to map back the Phrases to their source RhythmVoices
        for (var baseRv : mapBaseRvMgDelegate.keySet())
        {
            var targetRv = mapBaseRvMgDelegate.get(baseRv).rv;
            if (baseRv != targetRv)
            {
                Phrase p = targetRv.getContainer() != baseRhythm ? mapRvPhrases.remove(targetRv) : mapRvPhrases.get(targetRv);
                assert p != null : "targetRv=" + targetRv + " baseRv=" + baseRv;
                mapRvPhrases.put(baseRv, p);
            }
        }
        res.putAll(mapRvPhrases);

        return res;
    }

    /**
     * Merge phrases from src into dest.
     *
     * @param mm
     * @param mapDest
     * @param mapSrc
     */
    private void mergePhrases(MidiMix mm, Map<RhythmVoice, Phrase> mapDest, Map<RhythmVoice, Phrase> mapSrc)
    {
        for (var rv : mapSrc.keySet())
        {
            var pSrc = mapSrc.get(rv);
            mapDest.putIfAbsent(rv, new Phrase(mm.getChannel(rv)));
            var pDest = mapDest.get(rv);
            pDest.add(pSrc);
        }
    }

    /**
     * A subpart of context.
     *
     * @param context
     * @param spts
     * @return
     */
    private SongContext getSubContext(SongContext context, List<SongPart> spts)
    {
        return new SongContext(context, new IntRange(spts.getFirst().getStartBarIndex(), spts.getLast().getBarRange().to));
    }

    /**
     * Create a new context with the baseRhythm replaced and possibly some variation values updated.
     *
     * @param context
     * @param delegateRhythm
     * @param rpVariationValue The MgDelegates must have the same rpVariation value
     * @return
     * @throws org.jjazz.rhythm.api.MusicGenerationException
     */
    private SongContext createDelegateContext(SongContext context, Rhythm delegateRhythm, String rpVariationValue) throws MusicGenerationException
    {
        SongContext res = context.deepClone(false, true);       // setMidiMixSong=true because MidiMix must update itself when we will later replace the rhythm


        // Replace rhythm
        SongStructure sgsCopy = res.getSong().getSongStructure();
        var targetOldSpts = context.getSongParts().stream()
                .filter(spt -> spt.getRhythm() == baseRhythm)
                .map(spt -> sgsCopy.getSongPart(spt.getStartBarIndex()))
                .toList();

        var targetNewSpts = targetOldSpts.stream()
                .map(spt -> spt.clone(delegateRhythm, spt.getStartBarIndex(), spt.getNbBars(), spt.getParentSection()))
                .toList();
        try
        {
            sgsCopy.replaceSongParts(targetOldSpts, targetNewSpts);     // exception possible if not enough Midi channel
        } catch (UnsupportedEditException ex)
        {
            LOGGER.log(Level.WARNING, "createDelegateContext() Can not use delegate rhythm. context={0}, baseRhythm={1}, delegateRhythm={2}. ex={3}",
                    new Object[]
                    {
                        context, baseRhythm, delegateRhythm, ex.getMessage()
                    });
            String msg = ResUtil.getString(getClass(), "NotEnoughMidiChannelForDelegate", delegateRhythm.getName());
            throw new MusicGenerationException(msg);
        }

        // Update the variation value if needed
        if (rpVariationValue != null)
        {
            RP_SYS_Variation rpVariation = RP_SYS_Variation.getVariationRp(delegateRhythm);
            assert rpVariation != null : "delegateRhythm=" + delegateRhythm;
            targetNewSpts.stream()
                    .forEach(spt -> sgsCopy.setRhythmParameterValue(spt, rpVariation, rpVariationValue));
        }

        return res;
    }

    /**
     * Post-process each phrase with its (optional) post-processor defined in the MgDelegate.
     *
     * @param mapBaseRvPhrases
     * @param mapBaseRvMgDelegate
     */
    private void postProcessPhrases(Map<RhythmVoice, Phrase> mapBaseRvPhrases, Map<RhythmVoice, MgDelegate> mapBaseRvMgDelegate)
    {
        for (var rv : mapBaseRvPhrases.keySet())
        {
            var processor = mapBaseRvMgDelegate.get(rv).postProcessor();
            if (processor != null)
            {
                LOGGER.log(LogLevel, "postProcessPhrases() post-processing phrase for rv={0}", rv);
                Phrase p = mapBaseRvPhrases.get(rv);
                processor.accept(p);
            }
        }
    }

}
