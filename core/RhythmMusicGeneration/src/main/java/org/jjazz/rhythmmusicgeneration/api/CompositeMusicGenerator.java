/*
 * 
 *   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *  
 *   Copyright @2019 Jerome Lelasseux. All rights reserved.
 * 
 *   This file is part of the JJazzLab software.
 *    
 *   JJazzLab is free software: you can redistribute it and/or modify
 *   it under the terms of the Lesser GNU General Public License (LGPLv3) 
 *   as published by the Free Software Foundation, either version 3 of the License, 
 *   or (at your option) any later version.
 * 
 *   JJazzLab is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Lesser General Public License for more details.
 *  
 *   You should have received a copy of the GNU Lesser General Public License
 *   along with JJazzLab.  If not, see <https://www.gnu.org/licenses/>
 *  
 *   Contributor(s): 
 * 
 */
package org.jjazz.rhythmmusicgeneration.api;

import com.google.common.base.Preconditions;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.MultimapBuilder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.StringJoiner;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import org.jjazz.chordleadsheet.api.UnsupportedEditException;
import org.jjazz.midimix.api.MidiMix;
import org.jjazz.phrase.api.Phrase;
import org.jjazz.phrase.api.Phrases;
import org.jjazz.rhythm.api.MusicGenerationException;
import org.jjazz.rhythm.api.Rhythm;
import org.jjazz.rhythm.api.RhythmVoice;
import org.jjazz.rhythm.api.rhythmparameters.RP_SYS_Variation;
import org.jjazz.rhythmmusicgeneration.spi.MusicGenerator;
import org.jjazz.songcontext.api.SongContext;
import org.jjazz.songstructure.api.SongPart;
import org.jjazz.songstructure.api.SongStructure;
import org.jjazz.utilities.api.IntRange;
import org.jjazz.utilities.api.MatrixGroupsRemover;
import org.jjazz.utilities.api.ResUtil;
import org.jjazz.utilities.api.Utilities;

/**
 * A MusicGenerator which delegates to other destination MusicGenerators.
 * <p>
 * Delegation mechanism is configured via the RvToDelegateUnitMapper class.
 * <p>
 * This lets a base Rhythm instance use more than one MusicGenerator, for example :<br>
 * - use an internal MusicGenerator for the bass RhythmVoice and another internal one for the rest of the RhythmVoices<br>
 * - use 2 internal MusicGenerators for the bass RhythmVoice, depending on the SongPart's RP_SYS_Variation value<br>
 * - use the percussion MusicGenerator from another Rhythm instance for our drums<br>
 * - use the Main-C bass track from another Rhythm with note velocities lowered so it better fits the other tracks of the base rhythm
 * <p>
 */
public class CompositeMusicGenerator implements MusicGenerator
{

    protected final static Level LogLevel = Level.FINE;


    /**
     * A delegate unit for a base RhythmVoice in the songPart context.
     *
     * @param songPart
     * @param rvBase           The base RhythmVoice
     * @param mg               The MusicGenerator delegate
     * @param rv               The delegate RhythmVoice to be used by mg.
     * @param rpVariationValue The delegate rhythm's variation to be used by mg. Will be ignored if delegate rhythm does not use the RP_SYS_Variation parameter.
     * @param postProcessor    An optional post-processor of the phrase generated by mg. If null no postprocessing is done. For example this can be used to
     *                         harmonize notes velocities.
     */
    public record DelegateUnit(SongPart songPart,
            RhythmVoice rvBase,
            MusicGenerator mg,
            RhythmVoice rv,
            String rpVariationValue,
            Consumer<Phrase> postProcessor)
            {

        public DelegateUnit
        {
            Objects.requireNonNull(songPart);
            Objects.requireNonNull(rvBase);
            Objects.requireNonNull(mg);
            Objects.requireNonNull(rv);
            Objects.requireNonNull(rpVariationValue);
        }

        /**
         * Constructor to use when rvBase has no delegate (delegates to itself).
         *
         * @param songPart
         * @param rvBase
         * @param mg
         * @param rpVariationValue
         */
        public DelegateUnit(SongPart songPart, RhythmVoice rvBase, MusicGenerator mg, String rpVariationValue)
        {
            this(songPart, rvBase, mg, rvBase, rpVariationValue, null);
        }

        public Rhythm getBaseRhythm()
        {
            return rvBase.getContainer();
        }

        public Rhythm getDelegateRhythm()
        {
            return rv.getContainer();
        }

//        @Override
//        public String toString()
//        {
//            return toDebugString();
//        }

        public String toDebugString()
        {
            StringJoiner joiner = new StringJoiner(", ", "RvDelegateUnit(", ")");
            joiner.add(songPart.getName());
            joiner.add("rvBase=" + rvBase.toString());
            joiner.add(mg.getClass().getSimpleName());
            joiner.add(rv.toString());
            joiner.add(rpVariationValue);
            joiner.add(postProcessor() == null ? "null" : postProcessor().getClass().getSimpleName());
            return joiner.toString();
        }
    }

    /**
     * Map a base RhythmVoice to a DelegateUnit for a given SongPart context.
     */
    public interface RvToDelegateUnitMapper
    {

        /**
         * Get the DelegateUnit to be used to generate music for baseRv in the context of songPart.
         *
         * @param baseRv A RhythmVoice of the baseRhythm. Can not be null.
         * @param spt    A SongPart which uses the baseRhythm. Can not be null.
         * @return A non-null value
         */
        DelegateUnit get(RhythmVoice baseRv, SongPart spt);
    }


    /**
     * A MusicGenerator for a set of base-destination RhythmVoice mappings.
     */
    private record MgConfig(MusicGenerator mg, Map<RhythmVoice, RhythmVoice> mapRvBaseDest)
            {

        @Override
        public String toString()
        {
            return "MgConfig[" + mg.getClass().getSimpleName() + "," + mapRvBaseDest.toString() + "]";
        }
    }


    private final RvToDelegateUnitMapper baseRvToDelegateUnitMapper;
    private final Rhythm baseRhythm;
    private static final Logger LOGGER = Logger.getLogger(CompositeMusicGenerator.class.getSimpleName());


    /**
     * Create a CompositeMusicGenerator for a base Rhythm.
     *
     * @param baseRhythm
     * @param baseRvMapper
     */
    public CompositeMusicGenerator(Rhythm baseRhythm, RvToDelegateUnitMapper baseRvMapper)
    {
        Objects.requireNonNull(baseRhythm);
        Objects.requireNonNull(baseRvMapper);
        this.baseRhythm = baseRhythm;
        this.baseRvToDelegateUnitMapper = baseRvMapper;
    }

    public Rhythm getBaseRhythm()
    {
        return baseRhythm;
    }

    @Override
    public Map<RhythmVoice, Phrase> generateMusic(SongContext sgContext, RhythmVoice... rvs) throws MusicGenerationException
    {
        var rvsList = List.of(rvs);
        var rhythmRvs = baseRhythm.getRhythmVoices();
        Preconditions.checkArgument(rvsList.stream().allMatch(rv -> rhythmRvs.contains(rv)), "rvs=", rvsList);
        var rhythmVoices = rvsList.isEmpty() ? rhythmRvs : rvsList;


        Map<RhythmVoice, Phrase> res = new HashMap<>();


        // The SongParts using our rhythm
        var baseRhythmSpts = sgContext.getSongParts().stream()
                .filter(spt -> spt.getRhythm() == baseRhythm)
                .toList();

        LOGGER.log(LogLevel, " ");
        LOGGER.log(LogLevel, "=========================================================");
        LOGGER.log(LogLevel, "generateMusic() -- song={0}  barRange={1}  {2}", new Object[]
        {
            sgContext.getSong().getName(), sgContext.getBarRange(), rhythmVoices
        });

        //
        // We want to minimize the number of MusicGenerator calls:
        // - A single MusicGenerator call can encompass several SongParts if they share the same MgConfig.
        // - Within one SongPart, 2 MusicGenerator calls are required if 2 RvDelegateUnits use the same delegate rhythm with different rpVariationValues.
        //

        // Get the MgConfigs with their RvDelegateUnits ready to be processed
        ListMultimap<MgConfig, DelegateUnit> mmapMgConfigToDelegateUnits = getMgConfigsMultiMap(baseRhythmSpts, rhythmVoices);


        // Process each mgConfig
        for (var mgConfig : mmapMgConfigToDelegateUnits.keySet())
        {
            var delegateUnits = mmapMgConfigToDelegateUnits.get(mgConfig);
            var spts = toOrderedSongPartList(delegateUnits.stream()
                    .map(du -> du.songPart())
                    .collect(Collectors.toSet()));


            if (LogLevel.intValue() >= Level.INFO.intValue())
            {
                LOGGER.log(LogLevel, "generateMusic() #### mgConfig.mg={0}", mgConfig.mg().getClass().getSimpleName());
                LOGGER.log(LogLevel, "  rvBaseDest=");
                LOGGER.log(LogLevel, Utilities.toMultilineString(mgConfig.mapRvBaseDest(), "    "));
                LOGGER.log(LogLevel, "  spts=");
                LOGGER.log(LogLevel, Utilities.toMultilineString(spts, "    "));
            }


            if (!spts.isEmpty())
            {
                // Call delegate generator
                Map<SongPart, String> mapSptVariation = getMapSptVariation(delegateUnits);
                var mapBaseRvPhrases = callDelegateGenerator(sgContext, mgConfig, mapSptVariation);     // throws MusicGenerationException
                postProcessPhrases(sgContext, mapBaseRvPhrases, delegateUnits);
                mergePhrases(sgContext.getMidiMix(), res, mapBaseRvPhrases);
            }

        }

        return res;
    }


    // =================================================================================================================================
    // Private methods
    // =================================================================================================================================
    /**
     * Get the variation used by each SongPart for the specified RvDelegateUnits.
     *
     * @param delegateUnits
     * @return
     */
    private Map<SongPart, String> getMapSptVariation(List<DelegateUnit> delegateUnits)
    {
        Map<SongPart, String> res = new HashMap();
        delegateUnits.forEach(unit -> res.put(unit.songPart(), unit.rpVariationValue()));
        return res;
    }

    /**
     * Get the MgConfigs with their associated RvDelegateUnits ready to be processed.
     * <p>
     * It is guaranteed that all MgConfig's RvDelegateUnits do not use multiple delegate variation values for a given SongPart.
     *
     * @param baseRhythmSpts
     * @param rhythmVoices
     * @return
     */
    private ListMultimap<MgConfig, DelegateUnit> getMgConfigsMultiMap(List<SongPart> baseRhythmSpts, List<RhythmVoice> rhythmVoices)
    {
        // Get all stuff
        ListMultimap<MgConfig, DelegateUnit> res = getAllMgConfigsMultimap(baseRhythmSpts, rhythmVoices);


        // Process RvDelegateUnits from SongParts with multiple delegate variation values
        for (var mgConfig : res.keySet().toArray(MgConfig[]::new))
        {
            var delegateUnits = res.get(mgConfig);

            List<SongPart> multiVariationSpts = toOrderedSongPartList(findMultiVariationSongParts(delegateUnits));
            var multiVariationDelegateUnits = delegateUnits.stream()
                    .filter(unit -> multiVariationSpts.contains(unit.songPart()))
                    .toList();

            // Now delegateUnits contains only mono-variation DelegateUnits, this updates res as well
            delegateUnits.removeAll(multiVariationDelegateUnits);


            // Turn the multi-variation DelegateUnits into new mono-variation DelegateUnits
            var mmapNewMgConfigDelegateUnits = createMonoVariationDelegateUnits(multiVariationSpts, mgConfig.mapRvBaseDest(), multiVariationDelegateUnits);


            // Add the new mono-variation mgConfigs 
            res.putAll(mmapNewMgConfigDelegateUnits);
        }

        return res;
    }

    /**
     * Process multi-variation DelegateUnits from a single MgConfig in order to find new MgConfigs with consistent groups of mono-variation DelegateUnits.
     * <p>
     * A "consistent group" of DelegateUnits means that they all use the same variation value for the same RhythmVoices in 1 or more SongParts. Smallest group
     * is 1 DelegateUnit.
     *
     * @param multiVariationSpts          From the same MgConfig instance
     * @param mapRvBaseDest               From the same MgConfig instance
     * @param multiVariationDelegateUnits From the same MgConfig instance
     * @return
     */
    private ListMultimap<MgConfig, DelegateUnit> createMonoVariationDelegateUnits(List<SongPart> multiVariationSpts,
            Map<RhythmVoice, RhythmVoice> mapRvBaseDest,
            List<DelegateUnit> multiVariationDelegateUnits)
    {
        ListMultimap<MgConfig, DelegateUnit> res = MultimapBuilder.hashKeys().arrayListValues().build();
        if (multiVariationSpts.isEmpty())
        {
            return res;
        }

        if (LogLevel.intValue() >= Level.INFO.intValue())
        {
            LOGGER.log(LogLevel, "createMonoVariationDelegateUnits() -- ");
            LOGGER.log(LogLevel, "  multiVariationSpts={0}", multiVariationSpts);
            LOGGER.log(LogLevel, "  mapRvBaseDest=");
            LOGGER.log(LogLevel, Utilities.toMultilineString(mapRvBaseDest, "    "));
            LOGGER.log(LogLevel, "  multiVariationDelegateUnits=");
            LOGGER.log(LogLevel, Utilities.toMultilineString(multiVariationDelegateUnits, "    "));
        }

        // Build a rpValuationValue matrix for each RhythmVoice-SongPart found in the parameters
        Rhythm r = multiVariationSpts.get(0).getRhythm();
        List<RhythmVoice> orderedBaseRvList = r.getRhythmVoices().stream()
                .filter(rv -> mapRvBaseDest.keySet().contains(rv))
                .toList();

        record DelegateUnitCell(DelegateUnit delegateUnit)
                {

            /**
             * Use only delegateUnit.rpVariationValue
             */
            @Override
            public boolean equals(Object obj)
            {
                DelegateUnitCell other = (DelegateUnitCell) obj;
                return Objects.equals(delegateUnit().rpVariationValue(), other.delegateUnit().rpVariationValue());
            }

            @Override
            public String toString()
            {
                return delegateUnit.toString();
            }
        }

        // Fill the matrix
        int rows = orderedBaseRvList.size();
        int cols = multiVariationSpts.size();
        DelegateUnitCell[][] matrix = new DelegateUnitCell[rows][cols];
        for (int sptIndex = 0; sptIndex < cols; sptIndex++)
        {
            var spt = multiVariationSpts.get(sptIndex);
            for (int rvIndex = 0; rvIndex < rows; rvIndex++)
            {
                var rv = orderedBaseRvList.get(rvIndex);
                var delegateUnit = multiVariationDelegateUnits.stream()
                        .filter(unit -> unit.songPart() == spt && unit.rvBase() == rv)
                        .findAny()
                        .orElseThrow(() -> new IllegalStateException("spt=" + spt + " rv=" + rv + " multiVariationDelegateUnits=" + multiVariationDelegateUnits));
                matrix[rvIndex][sptIndex] = new DelegateUnitCell(delegateUnit);
            }
        }

        // MatrixGroupsRemover.printMatrix(matrix);

        // Compute the groups
        MatrixGroupsRemover mgr = new MatrixGroupsRemover(matrix, 1);
        List<MatrixGroupsRemover.Group<DelegateUnitCell>> groups = mgr.findRemovalSequence();

        // MatrixGroupsRemover.printRemovalSequence(groups);

        // Create a MgConfig for each group
        for (var group : groups)
        {
            List<DelegateUnit> groupDelegateUnits = new ArrayList<>();
            Map<RhythmVoice, RhythmVoice> groupMapBaseRvDest = new HashMap<>();
            for (MatrixGroupsRemover.Cell cell : group.cells())
            {
                DelegateUnitCell dCell = matrix[cell.row()][cell.col()];
                var delegateUnit = dCell.delegateUnit();
                groupDelegateUnits.add(delegateUnit);
                groupMapBaseRvDest.put(delegateUnit.rvBase(), delegateUnit.rv());
            }


            var delegateUnit0 = groupDelegateUnits.getFirst();
            MgConfig mgConfig = new MgConfig(delegateUnit0.mg(), groupMapBaseRvDest);
            res.putAll(mgConfig, groupDelegateUnits);
            if (LogLevel.intValue() >= Level.INFO.intValue())
            {
                LOGGER.log(LogLevel, "createMonoVariationDelegateUnits() Adding new mgConfig={0}", mgConfig);
                LOGGER.log(LogLevel, "  delegateUnits={0}", groupDelegateUnits);
            }
        }

        return res;

    }


    /**
     * Get all the MgConfigs with their associated RvDelegateUnits -possibly with multiple delegate variations for a given SongPart.
     *
     * @param baseRhythmSpts
     * @param rhythmVoices
     * @return
     */
    private ListMultimap<MgConfig, DelegateUnit> getAllMgConfigsMultimap(List<SongPart> baseRhythmSpts, List<RhythmVoice> rhythmVoices)
    {
        ListMultimap<MgConfig, DelegateUnit> res = MultimapBuilder.hashKeys().arrayListValues().build();

        for (var spt : baseRhythmSpts)
        {
            List<MgConfig> mgConfigs = new ArrayList<>();
            ListMultimap<MusicGenerator, DelegateUnit> mmapMgToDelegateUnits = MultimapBuilder.hashKeys().arrayListValues().build();

            for (var rv : rhythmVoices)
            {
                var dlgUnit = baseRvToDelegateUnitMapper.get(rv, spt);
                mmapMgToDelegateUnits.put(dlgUnit.mg(), dlgUnit);
                var mgConfig = mgConfigs.stream()
                        .filter(mgc -> mgc.mg() == dlgUnit.mg())
                        .findAny()
                        .orElse(null);
                if (mgConfig == null)
                {
                    mgConfig = new MgConfig(dlgUnit.mg(), new HashMap<>());
                    mgConfigs.add(mgConfig);
                }
                mgConfig.mapRvBaseDest.put(rv, dlgUnit.rv());
            }

            for (var mgConfig : mgConfigs)
            {
                res.putAll(mgConfig, mmapMgToDelegateUnits.get(mgConfig.mg()));
            }
        }

        return res;
    }

    /**
     * Identify SongParts which use a delegate rhythm with at least 2 different variation values.
     *
     * @param delegateUnits
     * @return
     */
    private Set<SongPart> findMultiVariationSongParts(List<DelegateUnit> delegateUnits)
    {
        Set<SongPart> res = new HashSet<>();

        var spts = delegateUnits.stream()
                .map(du -> du.songPart())
                .collect(Collectors.toSet());

        for (var spt : spts)
        {
            Map<String, String> mapRhythmVariation = new HashMap<>();
            for (var delegateUnit : delegateUnits)
            {
                if (delegateUnit.songPart() != spt)
                {
                    continue;
                }
                var variation = delegateUnit.rpVariationValue();
                String rhythmId = delegateUnit.getDelegateRhythm().getUniqueId();
                if (mapRhythmVariation.containsKey(rhythmId) && !mapRhythmVariation.get(rhythmId).equals(variation))
                {
                    res.add(spt);
                } else
                {
                    mapRhythmVariation.put(rhythmId, variation);
                }
            }
        }
        return res;
    }

    /**
     * Generate phrases using a delegate generator for the mapSptRpVariationValue SongPart keys.
     * <p>
     *
     * @param songContext            General context
     * @param mgConfig               The delegate MusicGenerator and delegate RhythmVoice mappings
     * @param mapSptRpVariationValue The delegate rpVariationValue to use for each base Songpart
     *
     * @return One Phrase per base RhythmVoice, with music only for the mapSptRpVariationValue SongParts
     * @throws org.jjazz.rhythm.api.MusicGenerationException
     */
    private Map<RhythmVoice, Phrase> callDelegateGenerator(SongContext songContext, MgConfig mgConfig, Map<SongPart, String> mapSptRpVariationValue) throws MusicGenerationException
    {
        Objects.requireNonNull(songContext);
        Objects.requireNonNull(mgConfig);
        Preconditions.checkArgument(mapSptRpVariationValue != null && !mapSptRpVariationValue.isEmpty(), "mapSptRpVariationValue=%s", mapSptRpVariationValue);

        Map<RhythmVoice, Phrase> res = new HashMap<>();

        if (mgConfig.mapRvBaseDest().isEmpty())
        {
            LOGGER.log(LogLevel, "callDelegateGenerator() mapRvBaseDest empty => exiting");
            return res;
        }

        // We might have 2 times the same dest Rv if redirecting one base RhythmVoice to another base RhythmVoice
        Set<RhythmVoice> uniqueDelegateRvs = new HashSet<>(mgConfig.mapRvBaseDest().values());


        Rhythm delegateRhythm = uniqueDelegateRvs.iterator().next().getContainer();
        List<SongPart> baseSongParts = toOrderedSongPartList(mapSptRpVariationValue.keySet());


        // We need a delegateContext to use delegateRhythm instead of baseRhythm, with possibly an updated rpVariationValue
        SongContext delegateContext = createDelegateContext(songContext, delegateRhythm, mapSptRpVariationValue);
        // Destination SongParts are now available
        List<SongPart> destSongParts = baseSongParts.stream()
                .map(spt -> delegateContext.getSong().getSongStructure().getSongPart(spt.getStartBarIndex()))
                .toList();


        // Call MusicGenerator
        if (LogLevel.intValue() >= Level.INFO.intValue())
        {
            LOGGER.log(LogLevel, "callDelegateGenerator() --  mgConfig.mg={0}", mgConfig.mg().getClass().getSimpleName());
            LOGGER.log(LogLevel, "  barRange={0}", delegateContext.getBarRange());
            LOGGER.log(LogLevel, "  baseSongParts={0}", baseSongParts.stream().map(spt -> spt.toShortString()).toList());
            LOGGER.log(LogLevel, "  mapSptRpVariationValue={0}", mapSptRpVariationValue);
            LOGGER.log(LogLevel, "  mgConfig.mapBaseDestRv=");
            LOGGER.log(LogLevel, Utilities.toMultilineString(mgConfig.mapRvBaseDest(), "    "));
        }

        // Call the delegate generator
        var mapRvPhrases = mgConfig.mg().generateMusic(delegateContext, uniqueDelegateRvs.toArray(RhythmVoice[]::new));


        // Silence phrases parts which do not belong to songParts
        for (SongPart spt : delegateContext.getSongParts())
        {
            if (destSongParts.contains(spt))
            {
                continue;
            }
            LOGGER.log(LogLevel, "callDelegateGenerator() silencing phrase part for spt={0} beatRange={1}", new Object[]
            {
                spt,
                delegateContext.getSptBeatRange(spt)
            });
            var brSpt = delegateContext.getSptBeatRange(spt);
            for (Phrase p : mapRvPhrases.values())
            {
                Phrases.silence(p, brSpt, true, false, 0.1f);
            }
        }


        // Map back the Phrases to their source RhythmVoices
        for (var baseRv : mgConfig.mapRvBaseDest.keySet())
        {
            var targetRv = mgConfig.mapRvBaseDest.get(baseRv);
            if (baseRv != targetRv)
            {
                Phrase p = targetRv.getContainer() != baseRhythm ? mapRvPhrases.remove(targetRv) : mapRvPhrases.get(targetRv);
                assert p != null : "targetRv=" + targetRv + " baseRv=" + baseRv;
                mapRvPhrases.put(baseRv, p);
                LOGGER.log(LogLevel, "callDelegateGenerator() mapping p from {0} to {1}. p.size()={2}", new Object[]
                {
                    targetRv,
                    baseRv,
                    p.size()
                });
            }
        }
        res.putAll(mapRvPhrases);

        return res;
    }

    /**
     * Merge phrases from src into dest.
     *
     * @param mm
     * @param mapDest
     * @param mapSrc
     */
    private void mergePhrases(MidiMix mm, Map<RhythmVoice, Phrase> mapDest, Map<RhythmVoice, Phrase> mapSrc)
    {
        for (var rv : mapSrc.keySet())
        {
            var pSrc = mapSrc.get(rv);
            mapDest.putIfAbsent(rv, new Phrase(mm.getChannel(rv), pSrc.isDrums()));
            var pDest = mapDest.get(rv);
            pDest.add(pSrc);
        }
    }

    /**
     * A subpart of context which only use spts (or part of spts).
     *
     * @param context
     * @param spts
     * @return
     */
    private SongContext getSubContext(SongContext context, List<SongPart> spts)
    {
        IntRange br = context.getBarRange().getIntersection(new IntRange(spts.getFirst().getStartBarIndex(), spts.getLast().getBarRange().to));
        return new SongContext(context, br);
    }

    /**
     * Create a new delegate context adapted to the impacted SongParts (the mapSptRpVariationValue keys).
     * <p>
     * Changes: <br>
     * - bar range is limited to the bar range of the impacted SongParts (note that bar range might include non processed SongPart(s), they will be silenced
     * later).<br>
     * - baseRhythm is replaced by the delegateRhythm in the impacted SongParts, possibly with a rpVariation value update<br>
     *
     * @param context                The original context
     * @param delegateRhythm
     * @param mapSptRpVariationValue The destination rpVariationValue for each base SongPart
     * @return
     * @throws org.jjazz.rhythm.api.MusicGenerationException
     */
    private SongContext createDelegateContext(SongContext context, Rhythm delegateRhythm, Map<SongPart, String> mapSptRpVariationValue) throws MusicGenerationException
    {
        Preconditions.checkArgument(!mapSptRpVariationValue.isEmpty(), "context=%s delegateRhythm=%s", context, delegateRhythm);


        RP_SYS_Variation delegateRhythmRpVariation = RP_SYS_Variation.getVariationRp(delegateRhythm);
        var baseSpts = toOrderedSongPartList(mapSptRpVariationValue.keySet());
        IntRange br = context.getBarRange().getIntersection(new IntRange(baseSpts.getFirst().getStartBarIndex(), baseSpts.getLast().getBarRange().to));

        SongContext res;

        // Special case: delegateRhythm is baseRhythm and mapSptRpVariationValue does not bring any RpVariationValue change
        if (delegateRhythmRpVariation != null
                && baseSpts.stream()
                        .allMatch(spt -> spt.getRhythm() == delegateRhythm && spt.getRPValue(delegateRhythmRpVariation).equals(mapSptRpVariationValue.get(spt))))
        {
            // No need to change the SongStructure
            res = new SongContext(context, br);
        } else
        {
            // Need to change the SongStructure, create a getCopy context
            res = new SongContext(context, br).deepClone(false, true);   // setMidiMixSong=true because MidiMix must update itself when we will later replace the rhythm

            
            SongStructure sgsCopy = res.getSong().getSongStructure();
            var spts = toOrderedSongPartList(mapSptRpVariationValue.keySet());


            // Replace base rhythm by delegateRhythm               
            var oldSpts = spts.stream()
                    .map(spt -> sgsCopy.getSongPart(spt.getStartBarIndex()))
                    .toList();
            var newSpts = oldSpts.stream()
                    .map(spt -> spt.getCopy(delegateRhythm, spt.getStartBarIndex(), spt.getNbBars(), spt.getParentSection()))
                    .toList();
            try
            {
                sgsCopy.replaceSongParts(oldSpts, newSpts);     // exception possible if not enough Midi channel
            } catch (UnsupportedEditException ex)
            {
                LOGGER.log(Level.WARNING, "createDelegateContext() Can not use delegate rhythm. context={0}, baseRhythm={1}, delegateRhythm={2}. ex={3}",
                        new Object[]
                        {
                            context, baseRhythm, delegateRhythm, ex.getMessage()
                        });
                String msg = ResUtil.getString(getClass(), "NotEnoughMidiChannelForDelegate", delegateRhythm.getName());
                throw new MusicGenerationException(msg);
            }

            // Possibly update rpVariationValue of some SongParts
            if (delegateRhythmRpVariation != null)
            {
                for (int i = 0; i < newSpts.size(); i++)
                {
                    var newSpt = newSpts.get(i);
                    var rpVariationValue = newSpt.getRPValue(delegateRhythmRpVariation);
                    var mapSpt = spts.get(i);
                    var destVariationValue = mapSptRpVariationValue.get(mapSpt);
                    if (!rpVariationValue.equals(destVariationValue))
                    {
                        LOGGER.log(LogLevel, "createDelegateContext() targetSpt={0}: setting delegate variation value to {1}",
                                new Object[]
                                {
                                    newSpt, destVariationValue
                                });
                        sgsCopy.setRhythmParameterValue(newSpt, delegateRhythmRpVariation, destVariationValue);
                    }
                }
            }
        }

        return res;
    }

    /**
     * Post-process each phrase per SongPart for each DelegateUnit having a defined post-processor.
     *
     * @param sgContext
     * @param mapBaseRvPhrases
     * @param delegateUnits
     */
    private void postProcessPhrases(SongContext sgContext, Map<RhythmVoice, Phrase> mapBaseRvPhrases, List<DelegateUnit> delegateUnits)
    {
        for (var delegateUnit : delegateUnits)
        {
            var postProcessor = delegateUnit.postProcessor();
            if (postProcessor == null)
            {
                continue;
            }

            var spt = delegateUnit.songPart();
            var brSpt = sgContext.getSptBeatRange(spt);
            var rvBase = delegateUnit.rvBase();
            LOGGER.log(LogLevel, "postProcessPhrases() post-processing phrase for spt={0} rvBase={1}", new Object[]
            {
                spt, rvBase
            });

            var p = mapBaseRvPhrases.get(rvBase);
            var pSpt = p.clone();
            Phrases.getSlice(pSpt, brSpt, false, 1, 0.1f);  // keep only the SongPart slice before processing it
            postProcessor.accept(pSpt);
            Phrases.silence(p, brSpt, true, false, 0.1f);     // insert pSpt back in original phrase
            p.add(pSpt);
        }
    }

    /**
     * Convert a SongPart set into an ordered SongPart list.
     *
     * @param spts
     * @return
     */
    private List<SongPart> toOrderedSongPartList(Set<SongPart> spts)
    {
        List<SongPart> res = new ArrayList<>(spts);
        res.sort((spt1, spt2) -> Integer.compare(spt1.getStartBarIndex(), spt2.getStartBarIndex()));
        return res;
    }

}
